<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1, interactive-widget=resizes-content"/>
    <title>CW Trainer</title>
    <link rel="icon" type="image/x-icon" href="cw-trainer.ico">

    <style>
      body {
        width : 380px;
        font-family: sans-serif;
        margin: 2px 0 0 5px;
      }
      h2 {
        margin : 0;
        user-select: none;
      }
      span {
        letter-spacing: 1px;
        font-family: monospace;
        font-size: large;
      }
      table {
        width: 100%;
        max-height: 500px;
        display: block;
        overflow-y: auto;
      }
      th {
        position: sticky;
        top: 0;
        background-color: white;
      }
      th, td {
        padding:2px 15px;
        text-align : center;
      }
      td:not(:last-child), th:not(:last-child) {
        border-right: solid 1px;
      }
      a {
        text-decoration : none;
      }
      textarea {
        width: 368px;
      }
      small {
        color: #a0a0a0;
      }
      label[for='seleffwpm'] {
        margin-left: 15px;
      }
      select, input[type="button"] {
        height: 21px;
        display: inline-block !important;
      }
      #player button {
        width: 32px;
        height: 28px;
        vertical-align: top;
        margin-bottom: 5px;
        padding: 2px 0 0 0;
      }
      #iptfree {
        width: 310px;
        height: 100px;
        font-size: 48pt;
        text-align: center;
        text-transform: uppercase;
      }
      #keyboard {
        display: none;
        margin-top : 3px;
        width : 380px;
        position: absolute;
        bottom: 0;
      }
      #keyboard input[type='button'] {
        width: 45px;
        height: 36px;
        margin: 1px;
        font-size: 18pt;
      }
      #zonedkb {
        display: none;
      }
      #clearzone {
        background-color: #ddd;
      }
      .zonecontrols {
        margin-bottom: 5px;
      }
      .svg_inactif {
        fill: grey;
      }
      .right {
        color : green;
      }
      .wrong {
        color: #d00;
        text-decoration : line-through;
        font-weight : bold;
      }
      .error {
        background-color: #d00;
        color: white;
      }
      .ok {
        background-color: green;
        color: white;
      }
      .progress-container {
        display: inline-block;
      }
      .progress-bar {
        height: 25px;
        background-color: #ddd;
        border-radius: 2px;
        position:relative;
        width: 261px;
        top: 2px;
      }
      .progress {
        height: 100%;
        border-radius: 2px;
        background: #49aade/*linear-gradient(to right, #ffbf00 0%, #ff007f 100%)*/;
        width: 0%;
        position:relative;
      }
      .progress-bar center {
        position:absolute;
        left:0;
        right:0;
        top:0;
        bottom:0;
        margin:auto;
        margin-top: 3px;
      }
      .progress-bar span {
        font-family: sans-serif;
        font-size: inherit;
      }
    </style>
  </head>
<body>
<div>
  <h2 id="cwtitle">CW Trainer <a href="#" onclick="selfDownload()" title="save CW Trainer for offline use">&#x0001f4be;</a></h2>
  <div class="zonecontrols">
    <label for="sellesson">Lesson : </label>
    <input type="button" id="prevlesson" value="&lt;"><select id="sellesson">
      <option value='1'>1 - K, M</option><option value='2'>2 - U</option><option value='3'>3 - R</option><option value='4'>4 - E</option><option value='5'>5 - S</option><option value='6'>6 - N</option><option value='7'>7 - A</option><option value='8'>8 - P</option><option value='9'>9 - T</option><option value='10'>10 - L</option><option value='11'>11 - W</option><option value='12'>12 - I</option><option value='13'>13 - .</option><option value='14'>14 - J</option><option value='15'>15 - Z</option><option value='16'>16 - =</option><option value='17'>17 - F</option><option value='18'>18 - O</option><option value='19'>19 - Y</option><option value='20'>20 - ,</option><option value='21'>21 - V</option><option value='22'>22 - G</option><option value='23'>23 - 5</option><option value='24'>24 - /</option><option value='25'>25 - Q</option><option value='26'>26 - 9</option><option value='27'>27 - 2</option><option value='28'>28 - H</option><option value='29'>29 - 3</option><option value='30'>30 - 8</option><option value='31'>31 - B</option><option value='32'>32 - ?</option><option value='33'>33 - 4</option><option value='34'>34 - 7</option><option value='35'>35 - C</option><option value='36'>36 - 1</option><option value='37'>37 - D</option><option value='38'>38 - 6</option><option value='39'>39 - 0</option><option value='40'>40 - X</option>
      <option value='41'>QSO</option>
    </select><input type="button" id="nxtlesson" value="&gt;">
    <label for="seltone" title="Tone">Tone : </label>
    <input type="number" step="100" id="seltone" title="Tone"><small>&nbsp;(Hz)</small><BR>
    <label for="selwpm" title="Word Per Minute">WPM : </label>
    <input type="number" id="selwpm" title="Word Per Minute">
    <label for="seleffwpm" title="Effective Word Per Minute (Farnsworth)">Eff. WPM : </label>
    <input type="number" id="seleffwpm" title="Effective Word Per Minute (Farnsworth)"><BR>
  </div>
  <!--<span id="lamp">CW</span>-->
  <input type="checkbox" id="chkfree"><label for="chkfree">simple mode</label><input type="checkbox" id="chkfreelisten"><label for="chkfreelisten">free listen mode</label>
  <div id="zonefree" style="display:none">
    <input type="text" id="iptfree" maxlength="1">
    <div id="zoneresultfree"></div>
  </div>
  <div id="zonekoch">
    <label for="selews" title="Extra space between words (seconds)">Extra word spacing : </label>
    <input type="number" step="0.1" id="selews" title="Extra space between words (seconds)"><small>&nbsp;(seconds)</small><BR>
    <label for="grplen">Words length : </label>
    <select id="grplen">
      <option value="-1">random</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option>
    </select>
    <label for="groupsnb">Groups : </label>
    <input type="number" id="groupsnb" min="1" max="250">
    <div id="player">
      <button id="btnstop" onclick="cwplayer.stop()" title="stop playing" class="svg_inactif" disabled><!--x25A0-->
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20">
          <rect width="16" height="16" x="2" y="2" rx="1" ry="1"/>
        </svg>
      </button>
      <button id="btnplay" onclick="cwplayer.play()" title="start playing"><!--&#x25B6;-->
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="-10 -5 120 120">
          <path d="M 13.677242369053593 5.970459221108368 L 99.32275763094641 55.02954077889163 C 103.6613788154732 57.514770389445815 103.50196896806634 62.18351020967654 99.00393793613266 64.36702041935308 L 13.996062063867347 105.63297958064692 C 9.498031031933674 107.81648979032346 5 105 5 100 L 5 11 C 5 6 9.338621184526797 3.485229610554184 13.677242369053593 5.970459221108368 Z" />
        </svg>
      </button>
      <button id="btnpause" onclick="cwplayer.pause()" title="pause playing" class="svg_inactif" disabled><!--&#x23F8;-->
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20" height="20" viewBox="0 0 20 20">
          <rect width="5" height="15" x="3" y="2" rx="1" ry="1"/>
          <rect width="5" height="15" x="12" y="2" rx="1" ry="1"/>
        </svg>
      </button>
      <div class="progress-container">
        <div class="progress-bar">
          <div id="playperc" class="progress"></div>
          <center><span id="playtime"></span></center>
        </div>
      </div>
    </div>
    <textarea id="cwtext" rows="4" cols="43" spellcheck="false" autocorrect="off"></textarea><br>
    <input type="button" value="submit" id="cwsbm">
    <span id="zonedkb"><input type="checkbox" id="disablekb"><label for="disablekb">disable keyboard</label></span><br>
    <div id="zoneresult" style="display:none;">
      <div id="zonerestext"></div>
      <input type="button" value="retry" id="retrybtn">
      <input type="button" value="next lesson !" id="retrynxt" onclick="nxtlesson.click()">
    </div>
  </div>
  <div id="keyboard"></div>
  <pre id="clearzone" style="display: none;"></pre>
</div>
<script>
const SVG_INACTIF = 'svg_inactif';
const HASHSEP = '_';
var cwchecking = false;
var cw_options = {
  lesson : 1,
  grouplen : 5,
  groupsnb : 10,
  wpm : 25,
  eff : 17,
  ews : 0.5,
  predelay : 2,
  tone : 800
};
var kochcars = ['K', 'M', 'U', 'R', 'E', 'S', 'N', 'A', 'P', 'T', 'L', 'W', 'I', '.', 'J', 'Z', '=', 'F', 'O', 'Y', ',', 'V', 'G', '5', '/', 'Q', '9', '2', 'H', '3', '8', 'B', '?', '4', '7', 'C', '1', 'D', '6', '0', 'X'];
var QSOs = [
  //http://lidscw.org/resources/cq-qso-template
  'CQ CQ CQ DE %IND1% %IND1% %IND1% PSE K',
  '%IND1% DE %IND2% %IND2% %IND2% KN',
  '%IND2% DE %IND1% = GA ES TNX FER CALL = UR RST %RST1% %RST1% = NAME IS %NAME1% %NAME1% QTH %QTH1% %QTH1% = HW? AR %IND2% DE %IND1% KN',
  '%IND1% DE %IND2% = GA %NAME1% TNX FB RPT UR RST %RST2% %RST2% =  OP %NAME2% %NAME2% ES QTH %QTH2% %QTH2% = HW? AR %IND1% DE %IND2% KN',
  '%IND2% DE %IND1% = R TNX RPT ES INFO %NAME2% = RIG IS FTDX1200 PWR 100W ANT IS YAGI = WX IS SUNNY ES WARM 100F = HW? AR %IND2% DE %IND1% KN',
  '%IND1% DE %IND2% = RIG IS FT817 5W ES ANT IS DIPOLE = WX IS WET AND COLD AR %IND1% DE %IND2% KN',
  '%IND2% DE %IND1% = MNI TNX INFO ES FB QSO = PSE QSL VIA BURO = 73 ES CUAGN AR %IND2% DE %IND1% SK',
  '%IND1% DE %IND2% = FB %NAME1% TNX FER NICE QSO 73 ES BCNU AR %IND1% DE %IND2% SK',
  //https://morsecode.ninja/files/Sample-Rag-Chew-QSO-v10.pdf
  'CQ CQ de %IND1% %IND1% K',
  '%IND1% de %IND2% %IND2% K',
  '%IND2% DE %IND1% = GA ES TNX FER THE CALL = UR RST IS %RST1% %RST1% = NAME HR %NAME1% %NAME1% MY QTH IS %QTH1% %QTH1% = HW CPY? %IND2% DE %IND1% KN',
  '%IND1% DE %IND2% R GA %NAME1% TNX FB RPT = RST %RST2% %RST2% = OP HR %NAME2% %NAME2% ES QTH %QTH2% %QTH2% = HW? %IND1% DE %IND2% K',
  'BK NAME? NAME? BK',
  'BK %NAME2% %NAME2% HW? BK',
  '%IND2% DE %IND1% = R R R TNX FER THE RPT ES INFO %NAME2% = MY RIG HR IS KX3 RUNS 100W WID AMP ES ANT IS A 4 ELE YAGI UP 76 FT = WX IS WET AND CO0L 45F = HW NW? %IND2% DE %IND1% K',
  '%IND1% DE %IND2% SOLID COPY %NAME1% = RIG ELECRAFT K3S RUNS KW ANT IS LOOP AT 65 FT = WX SUNNY ES WARM 88F = AGE 70 HAM FOR 40 YEARS = SO HW? %IND1% DE %IND2% KN',
  '%IND2% DE %IND1% = FB COPY %NAME2% WID QSB = AGE HR IS 50 ES BN A HAM FER 6 YRS = RECENTLY RETIRED BUT NW BACK TO WORK AS CERTIFIED TOWER MONKEY = %IND2% DE %IND1% K',
  '%IND1% DE %IND2% FB %NAME1% = RECENTLY RETIRED NURSE ANESTHETIST = LIVING THE DREAM = HW? %IND1% DE %IND2% K',
  '%IND2% DE %IND1% FB %NAME2% = GUD CPY WID MORE QSB HR = TNX FER THE INFO ES QSO = PSE QSL VIA LOTW = 73 ES HPE 2 CU AGN SK %IND2% DE %IND1% K',
  '%IND1% DE %IND2% = FB %NAME1% WL QSL LOTW ES TNX QSO GD 73 AR SK %IND1% DE %IND2% E E',
  //http://naqcc.info/cw_qsos.html
  '%IND1% DE %IND2% GM TNX CALL UR %RST1% %RST1% IN %QTH1% %QTH1% NAME IS %NAME1% %NAME1% HW? AR %IND1% DE %IND2% K',
  '%IND2% DE %IND1% GM %NAME1% UR %RST2% %RST2% IN %QTH2% %QTH2% NAME IS %NAME2% %NAME2% HW? AR %IND2% DE %IND1% KN',
  '%IND1% DE %IND2% R FB %NAME2% NICE TO MEET YOU BT THE RIG HR IS A KNWD TS-570D AT QRP 5W TO AN ATTIC RANDOM WIRE BT THE WX LITE SNOW ES 33 DEGREES HW? AR %IND1% DE %IND2% KN',
  '%IND2% DE %IND1% R FB ON ALL %NAME1% BT THE XYL SAYS SUPPER IS READY SO I MUST GO BT TNX QSO HPE CUL 73 GE SK %IND2% DE %IND1% K',
  '%IND1% DE %IND2% OK %NAME2% WONT HOLD YOU TNX QSO HPE CUAGN VY 73 GE SK %IND1% DE %IND2% E E'
  ];
function irand(start, end) {
  if (arguments.length < 2) {
    end = start;
    start = 0;
  }
  return Math.floor(Math.random()*(++end-start))+start;
}
function generateQTH(excepted=null) {
  const cities = ['NEW YORK', 'GRENOBLE', 'LAX', 'HAMBURG', 'BANGOR', 'ALGER', 'AMSTERDAM', 'BINGHAMTON',
  'BOTKYRKA', 'BUCHAREST', 'PALERMO', 'DRUMMONDVILLE', 'KRAKOW', 'LIMERICK', 'MANCHESTER', 'VILA VERDE', 'MELTON',
  'BARAKALDO', 'CARTAGENA', 'DRAMMEN', 'PARIS', 'BOMOMANI', 'MANIPAL', 'ALBANY', 'KITTANNING'];
  let qth = null;
  do {
    qth = cities[irand(cities.length-1)];
  }
  while (qth == excepted);
  return qth;
}
function generateRandomFirstname(excepted=null) {
  const fnames = ['STEVE', 'JANE', 'JOHN', 'ROY', 'MARTIN', 'SYLVAIN', 'PABLO', 'HENRY', 'FELIPE', 'LUCILLE', 'MARIA', 'JUAN', 'ROBERT', 'WILLIAM', 'CHARLEEN', 'PETE'];
  let fname = null;
  do {
    fname = fnames[irand(fnames.length-1)];
}
  while (fname == excepted);
  return fname;
}
function generateRandomCallsign(excepted=null) {
  const alpha = "ABCDEFGHIJKLMNPQRSTUVWXYZ";
  let rdnchar = () => alpha.charAt(irand(alpha.length));
  let cs = null;
  do {
    cs = rdnchar()+(Math.random()>0.8 ?rdnchar():'')+irand(1, 9)+rdnchar()+rdnchar()+(Math.random()>0.2?rdnchar():'')+(Math.random()>0.8 ?'/'+(Math.random()>=0.5?'P':'M'):'');
  }
  while (cs == excepted);
  return cs;
}
function generateRandomString(chars, len) {
  return Array.apply(null, Array(len)).map(() => {
    return chars[irand(chars.length-1)];
  }).join('');
}
function generateRandomText(chars, grouplen, groupsnb) {
  if (grouplen != -1) grouplen = Math.max(2, Math.min(8, grouplen));
  else grouplen = irand(2, 8);
  return Array.apply(null, Array(groupsnb)).map(() => generateRandomString(chars, grouplen)).join(' ');
}
async function generateText(evt) {
  if (!cwplayer) return;
  if (cwplayer.Playing) await cwplayer.stop();
  cw_options.lesson = parseInt(sellesson.value, 10);
  cwplayer.WPM = cw_options.wpm = parseInt(selwpm.value, 10);
  cwplayer.EffWPM = cw_options.eff = parseInt(seleffwpm.value, 10);
  cw_options.grouplen = parseInt(grplen.value, 10);
  cw_options.groupsnb = parseInt(groupsnb.value, 10);
  cwplayer.EWS = cw_options.ews = parseFloat(selews.value);
  cwplayer.Tone = cw_options.tone = parseInt(seltone.value, 10);
  cwplayer.PreDelay = cw_options.predelay;
  // on remet à jour les contrôles si'il y'a eu des bornages
  selwpm.value = cw_options.wpm = cwplayer.WPM;
  seleffwpm.value = cw_options.eff = cwplayer.EffWPM;
  selews.value = cw_options.ews = cwplayer.EWS;
  seltone.value = cw_options.tone = cwplayer.Tone;
  let cwgentext = '';
  if (!chkfreelisten.checked) {
    if (chkfree.checked) {
      cwgentext = generateRandomString(kochcars.slice(0, cw_options.lesson+1), 1);
      cwplayer.PreDelay = 0;
    } else if (cw_options.lesson>40) {
      let callsign1 = generateRandomCallsign();
      let callsign2 = generateRandomCallsign(callsign1);
      let name1 = generateRandomFirstname();
      let name2 = generateRandomFirstname(name1);
      let qth1 = generateQTH();
      let qth2 = generateQTH(qth1);
      cwgentext = QSOs[irand(QSOs.length-1)]
          .replaceAll('%IND1%', callsign1)
          .replaceAll('%IND2%', callsign2)
          .replaceAll('%NAME1%', name1)
          .replaceAll('%NAME2%', name2)
          .replaceAll('%RST1%', ''+irand(5)+irand(9)+irand(9))
          .replaceAll('%RST2%', ''+irand(5)+irand(9)+irand(9));
    } else {
      cwgentext = generateRandomText(kochcars.slice(0, cw_options.lesson+1), cw_options.grouplen, cw_options.groupsnb);
    }
    cwplayer.Text = cwgentext;
  } else {
    cwplayer.PreDelay = 0;
    cwplayer.Text = chkfree.checked ? iptfree.value : cwtext.value;
  }
  saveParams();
}
// bug  compareStrings('C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR', 'C6YO. M?9RR C6YO.M?9RR C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR C6YO. M?9RR')
function compareStrings(str1, str2){
/*
 Ce qui suit est un algorithme de recherche des sous-chaines communes.
 On filtre ensuite les résultats pour les besoins du moment
 Source : 
https://stackoverflow.com/questions/28321273/how-to-find-the-most-common-part-of-a-string
https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring#JavaScript
https://stackoverflow.com/a/34807141
*/
  var sequences = {};
  if (str1 && str2) {
    var str1Length = str1.length,
      str2Length = str2.length,
      num = new Array(str1Length),
      idx = null;
  
    for (var i = 0; i < str1Length; i++) {
      var subArray = new Array(str2Length);
      for (var j = 0; j < str2Length; j++)
        subArray[j] = 0;
      num[i] = subArray;
    }
    for (var i = 0; i < str1Length; i++)
    {
      for (var j = 0; j < str2Length; j++)
      {
        if (str1[i] !== str2[j])
          num[i][j] = 0;
        else
        {
          if ((i === 0) || (j === 0))
            num[i][j] = 1;
          else
            num[i][j] = 1 + num[i - 1][j - 1];
   
          idx = (i - num[i][j] + 1)+","+(j - num[i][j] + 1);
          if (typeof sequences[idx] !== 'string') sequences[idx] = '';
          sequences[idx] += str1[i];
        }
      }
    }
  }
  sequences = Object.keys(sequences).map(k => {
    let idxs = k.split(',');
    return {'isrc' : parseInt(idxs[0], 10), 'idst' : parseInt(idxs[1], 10), 'text' : sequences[k]};
  });

  /******************************
  // FILTRAGE DES RESULTATS
   *****************************/
  // suppression des chaines communes contenues dans des chaines plus grandes
  sequences = sequences.filter(s =>
    !sequences.some(s2 => s2.text.length > s.text.length && ((s2.isrc <= s.isrc && s2.isrc+s2.text.length>s.isrc) || (s2.idst <= s.idst && s2.idst+s2.text.length>s.idst)))
  );
  // suppression des séquences qui apparaissent dans le désordre dans la chaine test par rapport à la chaine d'entrée (ainsi que les doublons, ex 'KMKMM/NNNK')
  sequences = sequences.filter((s, i) =>
    !sequences.some((s2, i2) => i2 < i && s2.idst >= s.idst)
  );
  // suppression des overlaps : compareStrings("IVNVV", "IVVV") todo bug '/UQ/T','/QT'
  sequences = sequences.filter((s,i) => !sequences.some((s2,i2) => i2>i && (s.isrc==s2.isrc || s.idst==s2.idst)));
  return {'str1':str1, 'str2':str2, 'errors':str1.length-sequences.reduce((acc, cur) => acc+=cur.text.length, 0), 'sequences': sequences};
}
const emptyChar = '&nbsp;';//'_';
function formatTestString(ret) {
  let sret = '';
  let sequences = ret.sequences, str1=ret.str1, str2=ret.str2;
  if (!sequences.length && str2.length) {
    // affichage de toute la chaine de test (fausse)
    sret += `<span class="wrong">${str2}</span>`;
  } else if (!sequences.length && str1.length && !str2.length) {
    // affichage du bon nombre de caractères vide
    sret += `<span class="wrong">${emptyChar.repeat(str1.length)}</span>`;
  } else {
    let curl = 0;
    sequences.forEach(s => {
      if (s.idst > curl) {
        // affichage de tous les caractères de la chaine de test qui ne sont pas en préambule dans la chaine d'entrée
        sret += `<span class="wrong">${str2.substring(curl, s.idst)}</span>`;
        curl+=(s.idst-curl);
      }
      if (s.isrc > curl) {
        // affichage de tous les caractères de la chaine d'entrée qui ne sont pas en préambule dans la chaine de test
        sret += `<span class="wrong">${emptyChar.repeat(s.isrc-curl)}</span>`;
        curl+=(s.isrc-curl);
      }
      sret += `<span class="right">${s.text}</span>`;
      curl+=s.text.length;
    });
    let slast = sequences[sequences.length-1];
    let suffix = 0;
    if (slast.idst+slast.text.length < str2.length) {
      sret += `<span class="wrong">${str2.substring(slast.idst+slast.text.length)}</span>`;
      suffix += str2.length-(slast.idst+slast.text.length);
    }
    if (slast.isrc+slast.text.length+suffix < str1.length) {
      sret += `<span class="wrong">${emptyChar.repeat(str1.length-(slast.isrc+slast.text.length+suffix))}</span>`;
    }
  }
  return sret;
}
function key(value) {
  if (chkfree.checked) {
    iptfree.value+=value;
    iptfree.focus();
    verifycw();
  } else {
    cwtext.value+=value;
    cwtext.focus();
  }
}
async function verifycw() {
  if (!cwplayer || cwchecking) return;
  cwchecking = true;
  if (chkfree.checked) {
    if (iptfree.value?.length != 1) {
      cwchecking = false;
      return; // controls keys
    }
    //iptfree.disabled = true;
    if (chkfreelisten.checked || iptfree.value==' ') {
      await cwplayer.stop();
      await cwplayer.play(chkfreelisten.checked?iptfree.value:null);
      iptfree.value = '';
      //iptfree.disabled = false;
      iptfree.focus();
      cwchecking = false;
      return;
    }
    if (iptfree.value.toUpperCase() != cwplayer.Text[0]) {
      iptfree.classList.add('error');
      await cwplayer.stop();
      //play boop
      await cwplayer.playBoop();
      iptfree.classList.remove('error');
      if (window.freefirsttry) {
        window.freefirsttry = false;
        window.freeerr++;
      }
    } else {
      iptfree.classList.add('ok');
      CWPlayer.delay(0.15).then(() => iptfree.classList.remove('ok'));
      await generateText();
      await cwplayer.play();
      window.freetotal++;
      window.freefirsttry = true;
    }
    zoneresultfree.innerHTML = `Success rate : ${Math.round((100*(freetotal-freeerr)/freetotal)*10)/10}%`;

    iptfree.value = '';
    //iptfree.disabled = false;
    iptfree.focus();
  } else {
    if (chkfreelisten.checked) {
      return;
    }
    if (cwplayer.Playing) await cwplayer.stop();
    cwsbm.disabled = true;
    let extractfn = (t) => CWPlayer.cleanText(t.trim()).replaceAll('\t', ' ').split(' ').filter(e => e.length > 0);
    let inpt = extractfn(cwtext.value);
    let verif = extractfn(cwplayer.Text);
    if (inpt.length < verif.length) {
      if (confirm('Warning : it seems that you have not entered enough groups, are you sure to proceed to verification?')) {
        inpt.push(...Array(verif.length-inpt.length).fill(''));
      } else {
        cwsbm.disabled = false;
        cwchecking = false;
        return;
      }
    }
    
    let results = verif.map((a, i) => compareStrings(a, inpt[i]));
    let nbchars = verif.reduce((acc, cur) => acc+cur.length, 0);
    let nberr = results.reduce((acc, cur) => acc+cur.errors, 0);
    let perc = (nbchars-nberr)*100/nbchars;
    perc = Math.round(perc*10)/10;
    zonerestext.innerHTML = `${perc}% success rate (${nbchars-nberr}/${nbchars} characters sent)<BR>`;
    let restable = '<table><th>original</th><th>input</th><th>errors</th>'
    results.forEach(r => {
      restable += `<tr><td><span>${r.str1}</span></td>`;
      restable += `<td>${formatTestString(r)}</td>`;
      restable += `<td>${r.errors}</td></tr>`;
    });
    restable += '</table>';
    zonerestext.innerHTML += restable;
  
    retrynxt.style.visibility = perc>=90?'visible':'hidden';
    zoneresult.style.display = 'block';
  }
  cwchecking = false;
}

function selfDownload() {
  fetch(window.location.href)
    .then( res => res.blob() )
    .then( blob => {
      var url = window.URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = "cw_trainer.html";
      document.body.appendChild(a); // we need to append the element to the dom -> otherwise it will not work in firefox
      a.click();    
      a.remove();  //afterwards we remove the element again  
    });  
}
function generateKeyboard() {
  keyboard.innerHTML = '';
  let keybhtml = '';
  Object.keys(CWPlayer.morse).forEach(c => {
    if ((c>='A'&&c<='Z') || c==' ') return;
    else if (c == '"') c = '\\"';
    keybhtml += `<input type="button" value="${c}">`;
    if (c == '9') keybhtml += '<BR>';
  });
  keyboard.innerHTML = keybhtml;
  [...document.querySelectorAll('#keyboard input')].forEach(i => i.onclick=key.bind(i, i.value));
  placeKeyboard();
}
function placeKeyboard() {
  keyboard.style.bottom = Math.min(0, window.innerHeight-(document.documentElement.offsetHeight+keyboard.offsetHeight))+"px";
}
function setMinMax() {
  selwpm.min = CWPlayer.MIN_WPM;
  selwpm.max = CWPlayer.MAX_WPM;
  seleffwpm.min = CWPlayer.MIN_WPM;
  seleffwpm.max = CWPlayer.MAX_WPM;
  selews.min = CWPlayer.MIN_EWS;
  selews.max = CWPlayer.MAX_EWS;
  seltone.min = CWPlayer.MIN_TONE;
  seltone.max = CWPlayer.MAX_TONE;
}
function formatTime(t) {
  let tf = (Math.floor(t/60)+"").padStart(2, '0') + ':';
  let s = Math.round(10*(t%60))/10;
  if (s<10) tf += '0';
  s = s+"";
  if (s.indexOf('.') < 0) s+='.0';
  return tf+s;
}
function updateDisplayTime() {
  playperc.style.width = (100*cwplayer.CurrentTime/cwplayer.TotalTime)+'%';
  playtime.innerHTML = `${formatTime(cwplayer.CurrentTime)} / ${formatTime(cwplayer.TotalTime)}`;
}
function startTimeTimer() { window.timeTimer = window.setInterval(updateDisplayTime, 250); }
function stopTimeTimer() { window.clearInterval(window.timeTimer); }
function saveParams() {
  let params = encodeURIComponent(sellesson.value+HASHSEP+selwpm.value+HASHSEP+seleffwpm.value+HASHSEP+grplen.value+HASHSEP+groupsnb.value+HASHSEP+seltone.value+HASHSEP+selews.value+HASHSEP+(chkfree.checked?1:0));
  try {
    localStorage.setItem("params", params);
  } catch(e) {}
  window.location.hash = params;
}
function loadParams() {
  let params = window.location.hash.substring(1);
  if (params.trim().length <=0) {
    try {
      params = localStorage.getItem("params");
    } catch(e) {}
  }
  decodeURIComponent(params).split(HASHSEP).forEach((val, i) => {
    val = parseFloat(val);
    if (isNaN(val)) return;
    switch (i) {
      case 0:
        // pas length-1 car la leçon 41 existe (QSO)
        cw_options.lesson = Math.max(1, Math.min(kochcars.length, Math.trunc(val)));
        break;
      case 1:
        cw_options.wpm = Math.max(CWPlayer.MIN_WPM, Math.min(CWPlayer.MAX_WPM, Math.trunc(val)));
        break;
      case 2:
        cw_options.eff = Math.max(CWPlayer.MIN_WPM, Math.min(CWPlayer.MAX_WPM, Math.trunc(val)));
        break;
      case 3:
        cw_options.grouplen = Math.max(-1, Math.min(8, Math.trunc(val)));
        if (cw_options.grouplen == 0 || cw_options.grouplen == 1) cw_options.grouplen = 2;
        break;
      case 4:
        cw_options.groupsnb = Math.max(1, Math.min(250, Math.trunc(val)));
        break;
      case 5:
        cw_options.tone = Math.max(CWPlayer.MIN_TONE, Math.min(CWPlayer.MAX_TONE, Math.trunc(val)));
        break;
      case 6:
        cw_options.ews = Math.max(CWPlayer.MIN_EWS, Math.min(CWPlayer.MAX_EWS, val));
        break;
      case 7:
        chkfree.checked = val === 1;
        break;
    }
  });
}
function isTouchDevice() {
  return (('ontouchstart' in window) ||
     (navigator.maxTouchPoints > 0) ||
     (navigator.msMaxTouchPoints > 0));
}
function showKeyboard(evt) {
  if (disablekb.checked) return;
  keyboard.style.display = 'block';
  placeKeyboard();
}
function hideKeyboard(evt) {
  // on ne ferme pas le clavier dans ce cas
  if (evt && keyboard.contains(evt.relatedTarget)) return;
  keyboard.style.display = 'none';
}
function updateButtonsState() {
  let playing = cwplayer.Playing;
  btnpause.disabled = !playing;
  if (playing) {
    btnstop.classList.remove(SVG_INACTIF);
    btnpause.classList.remove(SVG_INACTIF);
    btnstop.disabled = false;
  } else {
    if (cwplayer.CurrentTime <= 0) btnstop.classList.add(SVG_INACTIF);
    btnpause.classList.add(SVG_INACTIF);
  }
  if (!playing && cwplayer.TotalTime > 0) {
    btnplay.disabled = false;
    btnplay.classList.remove(SVG_INACTIF);
  } else {
    btnplay.disabled = true;
    btnplay.classList.add(SVG_INACTIF);
  }
}
window.onload = async () => {
  window.cwplayer = new CWPlayer();
  setMinMax();
  loadParams();
  sellesson.value = cw_options.lesson;
  selwpm.value = cw_options.wpm;
  seleffwpm.value = cw_options.eff;
  grplen.value = cw_options.grouplen;
  groupsnb.value = cw_options.groupsnb;
  seltone.value = cw_options.tone;
  selews.value = cw_options.ews;
  cwplayer.addEventListener('play', () => {
    updateButtonsState();
    cwtext.focus();
    startTimeTimer();
  });
  cwplayer.addEventListener('pause', () => {
    updateButtonsState();
    stopTimeTimer();
  });
  cwplayer.addEventListener('stop', () => {
    updateButtonsState();
    stopTimeTimer();
    updateDisplayTime();
  });
  cwplayer.addEventListener('indexchanged', () => {
    if (cwplayer.Index>0) {
      clearzone.innerHTML = cwplayer.Text.substring(0, cwplayer.Index+1);
    }
  });
  cwplayer.addEventListener('parameterchanged', () => {
    updateDisplayTime();
    updateButtonsState();
  });
  // sur les périphériques à clavier virtuel on rajoute un autre clavier pour les touches spéciales
  // difficilement accessibles sur les claviers virtuels (soft keyboards)
  if (isTouchDevice() && window.innerHeight > document.documentElement.offsetHeight+200/*keyboard.offsetHeight*/) {
    generateKeyboard();
    zonedkb.style.display = 'initial';
    if (document.activeElement === cwtext || document.activeElement === iptfree) {
      showKeyboard();
    }
    cwtext.addEventListener("focus", showKeyboard);
    iptfree.addEventListener("focus", showKeyboard);
    cwtext.addEventListener("blur", hideKeyboard);
    iptfree.addEventListener("blur", hideKeyboard);
    window.addEventListener('resize', placeKeyboard);
    try {
      screen.orientation.addEventListener("change", placeKeyboard);
    } catch(e) {}
  }
  chkfree.onchange();//generateText();
};
window.onerror = (a, b, c, d, e) => {
  let err = `error : ${a}`;
  err += ` source: ${b}`;
  err += ` lineno: ${c}`;
  err += ` colno: ${d}`;
  err += ` error: ${e}`;
  alert(err);

  return false;
};
sellesson.onchange = () => {
  chkfree.onchange.call(this);
};
selwpm.onchange = () => {
  if (!cwplayer) return;
  cwplayer.WPM = selwpm.value;
  selwpm.value = cwplayer.WPM;
  seleffwpm.value = cwplayer.EffWPM;
  saveParams();
};
seleffwpm.onchange = () => {
  if (!cwplayer) return;
  cwplayer.EffWPM = seleffwpm.value;
  seleffwpm.value = cwplayer.EffWPM;
  selwpm.value = cwplayer.WPM;
  saveParams();
};
selews.onchange = () => {
  if (!cwplayer) return;
  cwplayer.EWS = selews.value;
  selews.value = cwplayer.EWS;
  saveParams();
};
seltone.onchange = () => {
  if (!cwplayer) return;
  cwplayer.Tone = seltone.value;
  seltone.value = cwplayer.Tone;
  saveParams();
}
grplen.onchange = generateText;
groupsnb.onchange = generateText;
cwsbm.onclick = verifycw;
retrybtn.onclick = () => {
  chkfree.onchange.call(this);
};
prevlesson.onclick = () => {
  sellesson.value = Math.max(1, parseInt(sellesson.value, 10)-1);
  chkfree.onchange.call(this);
};
nxtlesson.onclick = () => {
  sellesson.value = Math.min(41, parseInt(sellesson.value, 10)+1);
  chkfree.onchange.call(this);
};
chkfree.onchange = async () => {
  if (!cwplayer) return;
  await cwplayer.stop();
  zoneresult.style.display = 'none';
  zonefree.style.display = chkfree.checked?'block':'none';
  zonekoch.style.display = !chkfree.checked?'block':'none';
  cwsbm.disabled = chkfreelisten.checked;
  if (chkfree.checked) {
    iptfree.focus();
  } else {
    cwtext.focus();
  }
  iptfree.value = cwtext.value = '';
  cwplayer.AutoPlay = chkfreelisten.checked && !chkfree.checked;
  generateText();
  if (chkfreelisten.checked) {
    zoneresultfree.innerHTML = '';
    return;
  }
  zoneresultfree.innerHTML = 'Press space to hear first character';
  window.freeerr = 0;
  window.freetotal = 1;
  window.freefirsttry = true;
};
chkfreelisten.onchange = () => {
  chkfree.onchange.call(this);
};
cwtext.onkeyup = () => {
  if (!chkfreelisten.checked) return;
  cwplayer.Text = cwtext.value;
}
iptfree.onkeyup = verifycw;
cwtitle.ondblclick = () => clearzone.style.display = clearzone.style.display == 'none' ? 'block' : 'none';
disablekb.onchange = () => {
  if (disablekb.checked) {
    hideKeyboard();
  }
}
</script>

<script>
/*
  https://morsecode.world/international/timing.html
*/
class CWPlayer {
  static morse = {
    ' ' : '\t',
    'A' : '.-',
    'B' : '-...',
    'C' : '-.-.',
    'D' : '-..',
    'E' : '.',
    'F' : '..-.',
    'G' : '--.',
    'H' : '....',
    'I' : '..',
    'J' : '.---',
    'K' : '-.-',
    'L' : '.-..',
    'M' : '--',
    'N' : '-.',
    'O' : '---',
    'P' : '.--.',
    'Q' : '--.-',
    'R' : '.-.',
    'S' : '...',
    'T' : '-',
    'U' : '..-',
    'V' : '...-',
    'W' : '.--',
    'X' : '-..-',
    'Y' : '-.--',
    'Z' : '--..',
    '0' : '-----',
    '1' : '.----',
    '2' : '..---',
    '3' : '...--',
    '4' : '....-',
    '5' : '.....',
    '6' : '-....',
    '7' : '--...',
    '8' : '---..',
    '9' : '----.',
    '/' : '-..-.',
    '+' : '.-.-.',
    '=' : '-...-',
    '.' : '.-.-.-',
    ',' : '--..--',
    '"' : '.-..-.',
    '$' : '...-..-',
    '\'' : '.----.',
    '(' : '-.--.',
    ')' : '-.--.-',
    '[' : '-.--.',
    ']' : '-.--.-',
    '-' : '-....-',
    ':' : '---...',
    ';' : '-.-.-.',
    '@' : '.--.-.',
    '_' : '..--.-',
    '!' : '---.',
    '?' : '..--..'
  };
  DEFAULT_OPTIONS = {
    elperiod : 0.06, // 20WPM.
    spperiod : 0.06,
    tone : 800,
    ews : 0,
    predelay : 0,
    autoplay : false
  };
  constructor(options) {
    this.options = {...this.DEFAULT_OPTIONS, ...options};
    this.text = '';
    this.curti = -1;
    this.lastpausetime = this.totalpausetime = this.totaltime = 0;
    this.booping = this.playing = this.paused = false;
    this.events = {};
    if (this.options.wpm) {
      this.WPM = this.options.wpm;
    }
    if (this.options.effwpm) {
      this.EffWPM = this.options.effwpm;
    }
  }

  /*CONSTANTES*/
  static get MIN_WPM() { return 1; };
  static get MAX_WPM() { return 60; };
  static get MIN_EWS() { return 0; };
  static get MAX_EWS() { return 10; };
  static get MIN_TONE() { return 100; };
  static get MAX_TONE() { return 5000; };
  /*FIN CONSTANTES*/
  

  get WPM() {
    return Math.round(6 / (5 * this.options.elperiod));
  }
  set WPM(wpm) {
    wpm = isNaN(wpm) ? 0 : wpm;
    wpm = Math.min(CWPlayer.MAX_WPM, Math.max(CWPlayer.MIN_WPM, wpm));
    // "PARIS " ==> 50 unités. à 1 WPM il faut donc 60/50 secondes pour envoyer une unité (un 'dit')
    // Dit: 1 unit
    // Dah: 3 units
    // Intra-character space (the gap between dits and dahs within a character): 1 unit
    // Inter-character space (the gap between the characters of a word): 3 units
    // Word space (the gap between two words): 7 units
    let effwpm=this.EffWPM; // on sauvegarde ça sinon c'est perdu vu que ça s'appuie sur elperiod
    this.options.elperiod = 6 / (5 * wpm);
    this.options.spperiod = ((60/effwpm)-31*this.options.elperiod)/19;
    if (wpm<this.EffWPM) {
      this.EffWPM = wpm;
    } else {
      // ce traitement aurait déjà été fait dans le if dans le setter de EffWPM
      this.totaltime = this.getDuration();
    }
    this.fireEvent('parameterchanged');
  }
  get EffWPM() {
    return Math.round(60/(19*this.options.spperiod+31*this.options.elperiod));
  }
  set EffWPM(effwpm) {
    effwpm = isNaN(effwpm) ? 0 : effwpm;
    effwpm = Math.min(CWPlayer.MAX_WPM, Math.max(CWPlayer.MIN_WPM, effwpm));
    if (this.WPM<effwpm) {
      this.WPM = effwpm;
    }
    this.options.spperiod = ((60/effwpm)-31*this.options.elperiod)/19;
    this.totaltime = this.getDuration();
    this.fireEvent('parameterchanged');
  }
  get EWS() { return this.options.ews; }
  set EWS(value) {
    value = isNaN(value) ? 0 : value;
    value = Math.min(CWPlayer.MAX_EWS, Math.max(CWPlayer.MIN_EWS, value));
    this.options.ews = value;
    this.totaltime = this.getDuration();
    this.fireEvent('parameterchanged');
  }
  get Tone() { return this.options.tone; }
  set Tone(value) {
    value = isNaN(value) ? 0 : value;
    value = Math.min(CWPlayer.MAX_TONE, Math.max(CWPlayer.MIN_TONE, value));
    this.options.tone = value;
    if (this.context) {
      this.osc.frequency.value = this.options.tone;
    }
    this.fireEvent('parameterchanged');
  }
  get PreDelay() { return this.options.predelay; }
  set PreDelay(value) {
    value = isNaN(value) ? 0 : value;
    value = Math.max(0, value);
    this.options.predelay = value;
    this.totaltime = this.getDuration();
    this.fireEvent('parameterchanged');
  }
  get AutoPlay() { return this.options.autoplay; }
  set AutoPlay(value) {
    this.options.autoplay = !!value;
    this.fireEvent('parameterchanged');
  }
  get Playing() { return this.playing; }
  set Playing(value) {
    if (value === false && this.playing) {
      this.pause();
    } else if (value === true && !this.playing) {
      this.play();
    }
  }
  get Text() {
    return this.text;
  }
  set Text(value) {
    value = CWPlayer.cleanText(value);
    // si on modifie le texte qui a déjà été joué on remet la lecture à 0
    if (this.curti>=0 && (value.length<=this.curti || value.substring(0, this.curti) != this.text.substring(0, this.curti))) {
      this.stop();
    }
    this.text = value;
    this.totaltime = this.getDuration();
    this.fireEvent('parameterchanged');
    if (this.options.autoplay && !this.playing) {
      this.play();
    }
  }
  get Index() { return this.curti; }
  get TotalTime() { return this.totaltime;  }
  get CurrentTime() {
    if (this.paused) {
      return (this.lastpausetime-this.starttime-this.totalpausetime)/1000;
    } else if (this.playing) {
      return (performance.now()-this.starttime-this.totalpausetime)/1000;
    } else {
      return 0;
    }
  }

  fireEvent(evtname, args) {
    if (!this.events[evtname]) return;
    this.events[evtname].forEach(evt => evt(args));
  }
  addEventListener(evtname, cb) {
    if (!this.events[evtname]) this.events[evtname] = [];
    this.events[evtname].push(cb);
  }
  on(evtname, cb) { return addEventListener(evtname, cb); }
  removeEventListener(evtname, cb=null) {
    if (!this.events[evtname]) return;
    if (!cb) {
      delete this.events[evtname];
    } else {
      this.events[evtname] = this.events[evtname].filter(cb2 => cb2!==cb);
    }
  }
  static cleanText(text) {
    return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
      .toUpperCase()
      .replaceAll(/(\r?\n)+/g, '  ') // retour à la ligne : deux espaces
      .replaceAll(/[^A-Z0-9\/\+=\.,\?"\$\\\(\)\[\]\-\:;@_! ]/g, '?')
      /*.replaceAll(/\s+/g, ' ')*/;
  }
  static translate(text) {
    let cwtext = '';
    text = CWPlayer.cleanText(text);
    let isSpace = (c) => c == ' ' || c == '\t';
    for (let i=0; i<text.length; i++) {
      if (i>0 && !isSpace(text[i-1]) && !isSpace(text[i])) cwtext += ' '; // on rajoute un espace après tout caractère (sauf si le celui-ci ou le courant est un espace)
      cwtext += CWPlayer.morse[text[i]] ?? CWPlayer.morse['?'];
    }
    return cwtext;
  }

  #initAudio() {
    if (this.context) {
      return;
    }
    this.context = new (window.AudioContext || window.webkitAudioContext)();
    this.osc = this.context.createOscillator();
    this.gain = this.context.createGain();
    this.osc.connect(this.gain);//.connect(this.context.destination);
    this.osc.frequency.value = this.options.tone;
    this.gain.gain.value = 0;
    this.osc.start();
  }
  async stop(pause=false) {
    if (this.booping) return;
    this.paused = pause;
    if (!pause) {
      this.curti = -1;
      this.totalpausetime = this.lastpausetime = this.starttime = 0;
      this.fireEvent('indexchanged');
    }
    if (this.playing) {
      this.playing = false;
      this.gain.gain.cancelScheduledValues(this.context.currentTime);
      let curGain = this.gain.gain.value;
      if (curGain > 0) {
        let stopTime = this.context.currentTime + 0.005;
        this.gain.gain.linearRampToValueAtTime(curGain, this.context.currentTime);
        this.gain.gain.linearRampToValueAtTime(0, stopTime);
        await CWPlayer.delay(0.005);
      }
      try {
        this.gain.disconnect(this.context.destination);
      } catch(e) {}
    }
    this.fireEvent(pause?'pause':'stop');
  }
  async pause() {
    if (!this.playing || this.booping) return;
    this.lastpausetime = performance.now();
    return await this.stop(true);
  }
  async play(text) {
    if (this.playing || this.booping) return;
    if (this.lastpausetime > 0) {
      this.totalpausetime += (performance.now()-this.lastpausetime);
      this.lastpausetime = 0;
    }
    if (typeof text === 'string') this.Text = text;
    this.playing = true;
    this.paused = false;
    this.fireEvent('play');
    if (!this.context) {
      this.#initAudio();
    }
    this.gain.connect(this.context.destination);
    let localTime = performance.now();
    // on annule tous les autres threads de lecture
    this.currentPlay = localTime;
    if (this.starttime==0) {
      this.lastpausetime = this.totalpausetime = 0;
      this.starttime = localTime;
    }
    if (this.options.predelay>0) {
      // si la lecture a déjà commencée on pause le prédelai moins le temps déjà écoulé
      let predelay = Math.max(0, this.options.predelay-(performance.now()-this.starttime-this.totalpausetime)/1000);
      await CWPlayer.delay(predelay);
      // quit si pas le thread courant
      if (this.currentPlay != localTime) {
        return;
      }
    }
    while (this.playing && this.currentPlay == localTime) {
      if (++this.curti >= this.text.length) {
        return await this.stop();//le lecteur arrive en bout on stop
      }
      this.fireEvent('indexchanged');
      await this.#playElement(this.text[this.curti]);
      // on ajoute l'espacement inter caractère (si on est dans le thread courant, s'il reste des caractères à jouer et si le caractère courant ou suivant n'est pas un espace)
      if (this.playing && this.currentPlay == localTime && this.text[this.curti] != ' ' && this.text[this.curti] != '\t' && this.curti+1 < this.text.length && this.text[this.curti+1] != ' ' && this.text[this.curti+1] != '\t') {
        await CWPlayer.delay(this.options.spperiod*3);
      }
    }
  }
  async playBoop() {
    if (this.playing) {
      await this.stop();
    } else if (!this.context) {
      this.#initAudio();
    }
    this.gain.connect(this.context.destination);
    this.booping = true;

    let initTime = this.context.currentTime;
    let t = initTime;
    this.osc.frequency.setValueAtTime(500, t);
    this.gain.gain.setValueAtTime(0, t);
    this.gain.gain.linearRampToValueAtTime(1, t + 0.005);
    t += 0.1;
    this.osc.frequency.setValueAtTime(250, t);
    t += 0.1;
    this.gain.gain.setValueAtTime(1, t - 0.005);
    this.gain.gain.linearRampToValueAtTime(0, t);
    await CWPlayer.delay(t-initTime);
    this.booping = false;
  }

  static async delay(s) {
    return new Promise(res => s?setTimeout(res, s*1000):res())
  }
  async #playElement(c) {
    if (c == ' ' || c == '\t') {
      return await CWPlayer.delay(this.options.spperiod*7+this.options.ews);
    }
    let mc = CWPlayer.translate(c[0]);
    let initTime = this.context.currentTime;
    let t = initTime;
    this.osc.frequency.value = this.options.tone;
    for (let i=0; i<mc.length; i++) {
      if (i>0) {
        // inter-element
        t+=this.options.elperiod;
      }
      this.gain.gain.setValueAtTime(0, t);
      this.gain.gain.linearRampToValueAtTime(1, t + 0.005);
      t+=(mc[i] == '.' ? this.options.elperiod : 3*this.options.elperiod); // dit or dah
      this.gain.gain.setValueAtTime(1, t - 0.005);
      this.gain.gain.linearRampToValueAtTime(0, t);
    }
    await CWPlayer.delay(t-initTime);
  }
  getDuration() {
    if (this.text.length <= 0) return 0;
    let duration = Math.max(0, this.options.predelay), c = null;
    let inchar=false;
    let cwtext = CWPlayer.translate(this.text);
    for (let i=0; i<cwtext.length; i++) {
      c = cwtext[i];
      if (c == ' ') {
        duration += this.options.spperiod*3;
        inchar=false;
        continue;
      } else if (c == '\t') {
        duration += (this.options.spperiod*7+this.options.ews);
        inchar=false;
        continue;
      }
      if (inchar) {
        //inter-element
        duration+=this.options.elperiod;
      }
      duration+=(c == '.' ? this.options.elperiod : 3*this.options.elperiod); // dit or dah
      inchar=true;
    }
    return duration;
  }
}
</script>
</body>
</html>
